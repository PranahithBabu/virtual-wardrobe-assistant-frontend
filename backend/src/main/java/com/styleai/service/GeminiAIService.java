package com.styleai.service;

import com.styleai.dto.AIAnalysisResponse;
import com.styleai.dto.AIImageAnalysisRequest;
import com.styleai.dto.AIImageGenerationResponse;
import com.styleai.dto.AITextToImageRequest;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

@Service
public class GeminiAIService {

    @Value("${ai.gemini.api-key}")
    private String geminiApiKey;

    @Value("${ai.gemini.base-url}")
    private String geminiBaseUrl;

    private final RestTemplate restTemplate = new RestTemplate();
    private final Random random = new Random();

    public AIAnalysisResponse analyzeClothingImage(AIImageAnalysisRequest request) {
        // Check if we have a real API key
        if (geminiApiKey == null || geminiApiKey.equals("mock-gemini-key-for-development") || geminiApiKey.trim().isEmpty()) {
            return generateMockAnalysisFromImage();
        }
        
        try {
            // Try to call real Gemini API
            return callGeminiVisionAPI(request.getImageBase64());
        } catch (Exception e) {
            System.err.println("Gemini API call failed, falling back to mock data: " + e.getMessage());
            return generateMockAnalysisFromImage();
        }
    }

    public AIImageGenerationResponse generateClothingImage(AITextToImageRequest request) {
        // For now, return mock data. Gemini doesn't have image generation yet
        return generateMockImageFromText(request);
    }

    public AIAnalysisResponse analyzeTextForClothing(String itemName) {
        // Check if we have a real API key
        if (geminiApiKey == null || geminiApiKey.equals("mock-gemini-key-for-development") || geminiApiKey.trim().isEmpty()) {
            return generateMockAnalysisFromText(itemName);
        }
        
        try {
            // Try to call real Gemini API for text analysis
            return callGeminiTextAPI(itemName);
        } catch (Exception e) {
            System.err.println("Gemini API call failed, falling back to mock data: " + e.getMessage());
            return generateMockAnalysisFromText(itemName);
        }
    }

    private AIAnalysisResponse generateMockAnalysisFromImage() {
        // More realistic clothing items
        String[] names = {"Cotton T-Shirt", "Denim Jeans", "Leather Jacket", "Wool Sweater", "Silk Blouse", "Casual Shirt", "Dress Pants", "Hoodie", "Cardigan", "Tank Top"};
        String[] categories = {"Tops", "Bottoms", "Outerwear", "Dresses", "Shoes"};
        String[] colors = {"White", "Blue", "Black", "Red", "Gray", "Navy", "Beige", "Brown", "Green", "Pink"};
        List<String> allSeasons = Arrays.asList("Spring", "Summer", "Autumn", "Winter", "All");

        AIAnalysisResponse response = new AIAnalysisResponse();
        response.setName(names[random.nextInt(names.length)]);
        response.setCategory(categories[random.nextInt(categories.length)]);
        response.setColor(colors[random.nextInt(colors.length)]);
        
        // More realistic season selection
        int numSeasons = random.nextInt(3) + 1;
        List<String> selectedSeasons;
        if (numSeasons == 1 && random.nextBoolean()) {
            selectedSeasons = Arrays.asList("All");
        } else {
            selectedSeasons = allSeasons.subList(0, numSeasons);
        }
        response.setSeasons(selectedSeasons);
        
        response.setDataAiHint(response.getColor().toLowerCase() + " " + response.getName().toLowerCase());
        
        return response;
    }

    private AIImageGenerationResponse generateMockImageFromText(AITextToImageRequest request) {
        // Mock image URLs - in production, these would be generated by an image generation service
        String[] mockImageUrls = {
            "https://images.unsplash.com/photo-1521572163474-6864f9cf17ab?w=400&h=600&fit=crop",
            "https://images.unsplash.com/photo-1434389677669-e08b4cac3105?w=400&h=600&fit=crop",
            "https://images.unsplash.com/photo-1441986300917-64674bd600d8?w=400&h=600&fit=crop",
            "https://images.unsplash.com/photo-1516762689617-e1cffcef479d?w=400&h=600&fit=crop"
        };

        AIImageGenerationResponse response = new AIImageGenerationResponse();
        response.setImageUrl(mockImageUrls[random.nextInt(mockImageUrls.length)]);
        
        // Analyze the item name to suggest details
        AIAnalysisResponse analysis = analyzeTextForClothing(request.getItemName());
        response.setName(analysis.getName());
        response.setCategory(analysis.getCategory());
        response.setColor(analysis.getColor());
        response.setSeasons(analysis.getSeasons());
        response.setDataAiHint(analysis.getDataAiHint());
        
        return response;
    }

    private AIAnalysisResponse generateMockAnalysisFromText(String itemName) {
        AIAnalysisResponse response = new AIAnalysisResponse();
        String lowerName = itemName.toLowerCase();
        
        // Improved text analysis for category
        if (lowerName.contains("shirt") || lowerName.contains("tee") || lowerName.contains("t-shirt") || 
            lowerName.contains("top") || lowerName.contains("blouse") || lowerName.contains("sweater") || 
            lowerName.contains("hoodie") || lowerName.contains("cardigan") || lowerName.contains("tank")) {
            response.setCategory("Tops");
        } else if (lowerName.contains("jeans") || lowerName.contains("pants") || lowerName.contains("trousers") || 
                   lowerName.contains("shorts") || lowerName.contains("skirt") || lowerName.contains("leggings")) {
            response.setCategory("Bottoms");
        } else if (lowerName.contains("dress") || lowerName.contains("gown") || lowerName.contains("sundress")) {
            response.setCategory("Dresses");
        } else if (lowerName.contains("jacket") || lowerName.contains("coat") || lowerName.contains("blazer") || 
                   lowerName.contains("cardigan") || lowerName.contains("vest")) {
            response.setCategory("Outerwear");
        } else if (lowerName.contains("shoe") || lowerName.contains("sneaker") || lowerName.contains("boot") || 
                   lowerName.contains("sandal") || lowerName.contains("loafer") || lowerName.contains("heel")) {
            response.setCategory("Shoes");
        } else {
            response.setCategory("Accessories");
        }
        
        // Improved color detection
        String[] colors = {"white", "black", "blue", "red", "green", "yellow", "brown", "gray", "grey", "pink", "purple", "navy", "beige", "tan", "cream"};
        String detectedColor = "Black"; // Default color
        for (String color : colors) {
            if (lowerName.contains(color)) {
                detectedColor = color.substring(0, 1).toUpperCase() + color.substring(1);
                if (detectedColor.equals("Grey")) detectedColor = "Gray";
                break;
            }
        }
        response.setColor(detectedColor);
        
        // Improved seasons based on category and item type
        if (response.getCategory().equals("Outerwear") || lowerName.contains("coat") || lowerName.contains("jacket")) {
            if (lowerName.contains("winter") || lowerName.contains("wool") || lowerName.contains("heavy")) {
                response.setSeasons(Arrays.asList("Winter"));
            } else {
                response.setSeasons(Arrays.asList("Autumn", "Winter"));
            }
        } else if (lowerName.contains("shorts") || lowerName.contains("tank") || lowerName.contains("sundress") || 
                   lowerName.contains("sandal") || lowerName.contains("summer")) {
            response.setSeasons(Arrays.asList("Summer"));
        } else if (lowerName.contains("sweater") || lowerName.contains("wool") || lowerName.contains("winter")) {
            response.setSeasons(Arrays.asList("Winter"));
        } else if (lowerName.contains("light") || lowerName.contains("spring")) {
            response.setSeasons(Arrays.asList("Spring", "Summer"));
        } else {
            response.setSeasons(Arrays.asList("All"));
        }
        
        response.setName(itemName);
        response.setDataAiHint(detectedColor.toLowerCase() + " " + itemName.toLowerCase());
        
        return response;
    }

    // Method to call actual Gemini Vision API
    private AIAnalysisResponse callGeminiVisionAPI(String imageBase64) {
        try {
            HttpHeaders headers = new HttpHeaders();
            headers.set("Content-Type", "application/json");

            Map<String, Object> requestBody = new HashMap<>();
            
            // Gemini Vision API request structure
            Map<String, Object> contents = new HashMap<>();
            contents.put("parts", Arrays.asList(
                Map.of("text", "Analyze this clothing item and provide: name, category (Tops/Bottoms/Dresses/Outerwear/Shoes/Accessories), color, and suitable seasons (Spring/Summer/Autumn/Winter/All). Respond in JSON format with fields: name, category, color, seasons (array)."),
                Map.of("inline_data", Map.of(
                    "mime_type", "image/jpeg",
                    "data", imageBase64
                ))
            ));
            
            requestBody.put("contents", Arrays.asList(contents));
            
            HttpEntity<Map<String, Object>> entity = new HttpEntity<>(requestBody, headers);
            
            String url = geminiBaseUrl + "/models/gemini-pro-vision:generateContent?key=" + geminiApiKey;
            ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.POST, entity, Map.class);
            
            // Parse Gemini response and convert to AIAnalysisResponse
            return parseGeminiResponse(response.getBody());
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to call Gemini Vision API", e);
        }
    }

    // Method to call actual Gemini text API
    private AIAnalysisResponse callGeminiTextAPI(String itemName) {
        try {
            HttpHeaders headers = new HttpHeaders();
            headers.set("Content-Type", "application/json");

            Map<String, Object> requestBody = new HashMap<>();
            
            Map<String, Object> contents = new HashMap<>();
            contents.put("parts", Arrays.asList(
                Map.of("text", "Analyze this clothing item name: '" + itemName + "' and provide: category (Tops/Bottoms/Dresses/Outerwear/Shoes/Accessories), likely color, and suitable seasons (Spring/Summer/Autumn/Winter/All). Respond in JSON format with fields: name, category, color, seasons (array).")
            ));
            
            requestBody.put("contents", Arrays.asList(contents));
            
            HttpEntity<Map<String, Object>> entity = new HttpEntity<>(requestBody, headers);
            
            String url = geminiBaseUrl + "/models/gemini-pro:generateContent?key=" + geminiApiKey;
            ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.POST, entity, Map.class);
            
            // Parse Gemini response and convert to AIAnalysisResponse
            return parseGeminiResponse(response.getBody());
            
        } catch (Exception e) {
            throw new RuntimeException("Failed to call Gemini text API", e);
        }
    }

    private AIAnalysisResponse parseGeminiResponse(Map<String, Object> responseBody) {
        // This is a simplified parser - you'd need to implement proper JSON parsing
        // based on Gemini's actual response format
        AIAnalysisResponse response = new AIAnalysisResponse();
        
        try {
            // Extract the generated text from Gemini response
            List<Map<String, Object>> candidates = (List<Map<String, Object>>) responseBody.get("candidates");
            if (candidates != null && !candidates.isEmpty()) {
                Map<String, Object> content = (Map<String, Object>) candidates.get(0).get("content");
                List<Map<String, Object>> parts = (List<Map<String, Object>>) content.get("parts");
                if (parts != null && !parts.isEmpty()) {
                    String text = (String) parts.get(0).get("text");
                    
                    // Parse the JSON response from Gemini
                    // This would need proper JSON parsing in a real implementation
                    response.setName("Analyzed Item");
                    response.setCategory("Tops");
                    response.setColor("Blue");
                    response.setSeasons(Arrays.asList("All"));
                    response.setDataAiHint("analyzed item");
                }
            }
        } catch (Exception e) {
            // Fall back to mock data if parsing fails
            return generateMockAnalysisFromImage();
        }
        
        return response;
    }
}